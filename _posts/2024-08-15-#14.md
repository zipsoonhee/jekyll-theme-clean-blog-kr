---
layout: post
permalink: /osoma-marketing-study/
title: 8. 정형 데이터 분석
date: 2022-06-26 11:20:00 +09:00
feature: '/img/posts/14/0.jpg'
categories : [Marketing]


tags:
  - 마케팅스터디
  - 마개이너


description: 8. 정형 데이터 분석
---
# 8. 정형 데이터 분석
## 8-1. 정형 데이터 분석 관련 라이브러리

- **Numpy** : 과학/수학/통계 연산과 관련한 함수들의 집합
- 정형 데이터의 기본이 되는 형태로 초기 데이터 분석에 많이 활용
- 현재는 비정형 데이터 처리 및 분석에 주로 사용


```python
# 라이브러리 호출
import numpy as np
# 라이브러리 호출
# as 특정 패키지의 이름을 특정 약어 줄여 사용
```


```python
data = [6,5,7,3,2,1] #일반적인 Python 리스트 형태
sum(data)
#파이썬의 기본 자료구조를 사용할 땐, 파이썬의 기본 내장 함수들만 활용이 가능
```




    24




```python
# Numpy 라이브러리에서 통계량을 계산하는 함수나 연산을 이용하려면,
# Numpy 라이브러리 내에 있는 자료구조로 데이터를 선언
# 오류~ data.mean()

data1 = np.array(data) #이렇게 data를 선언하면, 리스트같은 구조가 나오지만 array가 붙으면서 np에서 사용할 수 있는 다양한 수식 활용가능.
data1
```




    array([6, 5, 7, 3, 2, 1])




```python
data1.mean()
```




    4.0




```python
type(data1) #Numpy의 대표적인 자료구조 ( 파이썬의 리스트와 동일한 특성을 가짐 )
```




    numpy.ndarray




```python
# (복습) 0부터 9까지의 정수를 리스트 형태로 선언
[ x for x in range(0,10) ] #이런 컴프리핸션을 파바박 떠올리기 어려워~
```




    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]




```python
#np.arange() : 정수를 차례대로 특정 수 전 까지 생성하는 함수 >> 파이썬의 리스트와 동일하게 편하게!!
np.arange(10)

#앞으로의 학습패턴은, 어떤 데이터에 어떤함수를 잘 써야할지에 초점을 맞춰서 진행해야 한다!
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
# 데이터의 타입을 지정할 수 있음
np.arange(10,dtype='float') #0-9까지 실수로 만들어라!
```




    array([0., 1., 2., 3., 4., 5., 6., 7., 8., 9.])




```python
#시작 위치를 지정 할 수 있음
np.arange(6,10,dtype='float') #6부터 시작하라!
```




    array([6., 7., 8., 9.])




```python
# 특정 간격을 두고 정수를 생성
np.arange(10, 11, 0.1) #10부터 11까지 0.1 간격으로 데이터를 생성하라!
```




    array([10. , 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 10.7, 10.8, 10.9])




```python
# 특정 간격의 개수를 지정하여 array를 구성할 수 있음
np.linspace(10, 20, 5) #10부터 20까지 5개의 데이터를 생성하고 싶어!
```




    array([10. , 12.5, 15. , 17.5, 20. ])




```python
# Numpy은 Matrix 형태의 자료구조를 구성 사용 (정형데이터의 기본)
data2 = np.linspace(100,200, 20)
data2
```




    array([100.        , 105.26315789, 110.52631579, 115.78947368,
           121.05263158, 126.31578947, 131.57894737, 136.84210526,
           142.10526316, 147.36842105, 152.63157895, 157.89473684,
           163.15789474, 168.42105263, 173.68421053, 178.94736842,
           184.21052632, 189.47368421, 194.73684211, 200.        ])




```python
#ndim : 데이터의 차원 수를 표현 # Svalar 0 / Vector 1 / Matrix 2 / 3-Tendsor 3 / 4-Tensor 4
data2.ndim
```




    1




```python
v1 = [[1,2,3],[4,5,6],[7,8,9]] #상자 안에 상자가 들어간 형태
v1[0]
```




    [1, 2, 3]




```python
data3 = np.array(v1)
data3 #행(가로)과 열(세로)로 구성된 2차원의 데이터 구성으로 바뀌게 됨
```




    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])




```python
data3.ndim
```




    2




```python
# 매트릭스와 매트릭스 끼리 사칙연산이 가능
# 두 Matrix의 사칙 연산 ( Matrix 연산 )
data4 = np.array([[1,2],[3,4],[5,6]]) # 리스트안에 리스트가 있는 이중 데이터 구조
data5 = np.array([[10,10],[1,1],[100,200]])
```


```python
data4 #3x2행렬
```




    array([[1, 2],
           [3, 4],
           [5, 6]])




```python
(data4 + data5)**2
```




    array([[  121,   144],
           [   16,    25],
           [11025, 42436]])




```python
# shape : 행과 열의 개수를 튜플 형태로 출력하는 매서드
data4.shape #shape은 함수가 아니라 메서드
```




    (3, 2)




```python
# Matrix안에는 숫자 뿐만 아니라 문자도 들어간다!
# 2차원 자료에 대한 Indexing (색인)
data6=np.array([['A','B','C'],['D','E','F'],['G','H','I']])
data6 #'U1' : 한 글자로 되어있는 문자열 (두 글자 <U2, 세글자 <U3)

```




    array([['A', 'B', 'C'],
           ['D', 'E', 'F'],
           ['G', 'H', 'I']], dtype='<U1')




```python
#0번째 위치 행의 데이터를 확인할 때
data6[0]
```




    array(['A', 'B', 'C'], dtype='<U1')




```python
# Indexing : [n,m] n행 m열의 데이터 확인

data6[0,1]

# 0행의 1열에 위치한 데이터를 추출 (기준, 0행 0열!)
```




    'B'




```python
# 특정 열의 데이터를 확인할 때
data6[:,0]

# 0열에 위치한 데이터를 확인
# : >> 특정 범위의 데이터를 찾음
```




    array(['A', 'D', 'G'], dtype='<U1')




```python
data6[1:3, 0] #1번부터 3번전까지(2번까지)의 범위의 행과 0번쩨 열을 추출
```




    array(['D', 'G'], dtype='<U1')




```python
#기존의 array구조의 Matrix에 새로운 행을 추가하고 싶을 때
np.vstack([data6,['N','M','O']]) #vertical stack - vstack : 새로운 행을 추가 (행,열이 맞춰줘야됨)
```




    array([['A', 'B', 'C'],
           ['D', 'E', 'F'],
           ['G', 'H', 'I'],
           ['N', 'M', 'O']], dtype='<U1')




```python
data6 #vstack썼다고 data6가 바뀌지 않는다 위의 새로운 추가된 결과를 사용하고 싶으면, 새로운 변수로 만들어줘야한다!
```




    array([['A', 'B', 'C'],
           ['D', 'E', 'F'],
           ['G', 'H', 'I']], dtype='<U1')




```python
[1,2,3].append(3)
```


```python
#새로운 열을 추가하는 경우
np.hstack([data6,[['M'],['N'],['P']]]) #추가하고자 하는 매트릭스 리스트에, 열을 넣어주기

# horizontal Stack - hstack
```




    array([['A', 'B', 'C', 'M'],
           ['D', 'E', 'F', 'N'],
           ['G', 'H', 'I', 'P']], dtype='<U1')




```python
#두 번째 행의 데이터를 변경
data6[1] = ['X','Y','Z']
```


```python
data6
```




    array([['A', 'B', 'C'],
           ['X', 'Y', 'Z'],
           ['G', 'H', 'I']], dtype='<U1')




```python
#0행 0열의 데이터를 변경, 특정 위치의 행렬에 값을 변경할 때
data6[0,0] = 'C'
```


```python
data6
```




    array([['C', 'B', 'C'],
           ['X', 'Y', 'Z'],
           ['G', 'H', 'I']], dtype='<U1')




```python
# 재구조화 (행렬의 구조를 변경)
data7 = np.array([10,20,30,40])
data7
```




    array([10, 20, 30, 40])




```python
# 1x4 Matrix ( 열이 0이면 Vector)를 2x2 Matrix로 변환 >> 구조가 보여지는 것만 바뀌는 것이지, data7자체가 바뀌진x
data7.reshape(2,2)
```




    array([[10, 20],
           [30, 40]])




```python
data7
```




    array([10, 20, 30, 40])




```python
data8 = np.array(range(1,10)) #arange 함수써도 똑같은 np.arange(0,10)
data8 #1x9 Vector -> 3x3 Matrix로 바꾸기
```




    array([1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
data8.reshape(3,3)
```




    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])




```python
data9 = data8.reshape(3,3)
#하나의 매트릭스를 하나의 열로 변환
data9.reshape(-1,1) #9x1열로 변환 , 앞으로 이런 형태를 정말 자주쓸거야!!
```




    array([[1],
           [2],
           [3],
           [4],
           [5],
           [6],
           [7],
           [8],
           [9]])




```python
#Numpy 난수 생성 가능!
data10 = np.random.randn(2,3) #2x3행렬을 생성 하는데, 난수로 이루어진!!
data10
```




    array([[-0.08415263, -0.3268258 ,  2.35524774],
           [-0.67257546,  0.12243015,  0.6394619 ]])




```python
#Matrix에 통계량을 계산하는 경우
data10.sum() # 행렬 내 데이터의 전체 합
```




    2.033585900652106




```python
data10.sum(axis=1) # 행단위로 계산 >> [첫째 가로줄 합산, 두번째 가로줄 합산]
```




    array([1.94426931, 0.08931659])




```python
data10.sum(axis= 0) # 열단위로 계산
```




    array([-0.75672809, -0.20439565,  2.99470964])




```python
data10.mean(axis=0) #각 열의 평균
```




    array([-0.37836404, -0.10219782,  1.49735482])



- **Pandas**
- 정형데이터 처리 밒 통계 관련한 함수들의 집합


```python
import pandas as pd #pd 약어는 어떻게 쓰든 상관은 없지만, 관용적으로 pd로 쓴다 #라이브러리 불러오기~>?
```


```python
# Series (순열) : Numpy Array를 기반으로 정형데이터 분석을 위해 구성된
# Index-Value 구조를 가진 Pandas 자료구조
s1 = pd.Series([100,200,700,400])
s1 #순서가 같이 따라나온다~ index에 대칭되는 값 = value

# 판다스에서 순열구조는 하나의 데이터 타입만 사용 가능,(숫자면 숫자, 문자면 문자)
# int64 : 64비트 수 / 숫자의 자릿수를 표현 하기 위한 수 2^64까지 표현이 가능한 것
```




    0    100
    1    200
    2    700
    3    400
    dtype: int64




```python
 pd.Series(['A',100,200,700,400])
```




    0      A
    1    100
    2    200
    3    700
    4    400
    dtype: object




```python
#dtype을 다 문자로 인식해버림
```


```python
#소괄호가 안붙으면 다 메서드, 붙으면 함수!!

s1.index #index의 정보를 메서드로 확인
```




    RangeIndex(start=0, stop=4, step=1)




```python
s1.values #Value의 정보를 확인
```




    array([100, 200, 700, 400], dtype=int64)




```python
# Series의 indexing
s1[0]
```




    100




```python
s1[0:2] #특정 범위의 값을 입력하면 index형태로 나옴!
```




    0    100
    1    200
    dtype: int64




```python
# 새로운 값을 특정 index에 추가하거나 변경하는 것도 가능
s1
```




    0    100
    1    200
    2    700
    3    400
    dtype: int64




```python
s1[4] = 500
```


```python
s1[2] = 300
```


```python
s1
```




    0    100
    1    200
    2    300
    3    400
    4    500
    dtype: int64




```python
s1.drop(1) #drop함수 : 특정 인덱스의 데이터를 제거 >> 결과만 나오고, s1데이터는 그대로이다
# 참고 : (삭제되거나 변경되는 값이 있을 때,) 같은 이름의 변수로 선언하지 않음
s2=s1.drop(1)
```


```python
s1
```




    0    100
    1    200
    2    300
    3    400
    4    500
    dtype: int64




```python
s1.mean()
```




    300.0




```python
s1.sum()
```




    1500




```python
s1.max()
```




    500




```python
s1.median() #중앙값, 중위수 : 데이터를 순서대로 나열했을 때, 위치상 가운데에 있는 값
```




    300.0




```python
s1
```




    0    100
    1    200
    2    300
    3    400
    4    500
    dtype: int64




```python
# Series는 자동으로 숫자가 부여되지만, 특정 원하는 값으로 사용자가 지정하는 것도 가능하다
s3=pd.Series([100,500,300,200], index=['A','B','C','D'])
s3

#Pandas 내 함수들을 사용할 때, 함수의 결과 Series 형태로 출력되는 경우
#Index값이 숫자가 아닌 경우가 있음
```




    A    100
    B    500
    C    300
    D    200
    dtype: int64




```python
s3['A'] #숫자가 아닌 index에 Indexing을 할 땐, 해당 index값으로 indexing 수행
```




    100




```python
# 딕셔너리를 활용해서 Series를 구성하는 방
# 딕셔너리의 키값이 Index로/ Value는 value로 선언
pd.Series({'name':'홍길동','age':28,'gender':'male','Job':'분석가'})
```




    name       홍길동
    age         28
    gender    male
    Job        분석가
    dtype: object




```python
#DataFrame 자료구조
#Index - Column - Value로 구성되어 있는 자료구조
#정형 데이터의 기본 구조와 동일한 형태로, Pandas에서 Excel이나, CSV, SQL과 같은 현태의 데이터를 다루고 처리

df = pd.DataFrame([100,200,300,400])
df
```


<br>
<br>
<br>
<br>
